import React, { useState } from 'react';
import clsx from 'clsx';
import { makeStyles } from '@material-ui/core/styles';
import Table from '@material-ui/core/Table';
import TableBody from '@material-ui/core/TableBody';
import TableCell from '@material-ui/core/TableCell';
import TableHead from '@material-ui/core/TableHead';
import TablePagination from '@material-ui/core/TablePagination';
import TableRow from '@material-ui/core/TableRow';
import TableSortLabel from '@material-ui/core/TableSortLabel';
import { all } from 'deepmerge';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function getHeaders(columns) {
  var maxDepth = getDepth(columns);
  var result = Array.from({
    length: maxDepth
  }).map(function () {
    return [];
  });

  function addItems(columns, depth) {
    columns.forEach(function (column) {
      var columnDef = _extends({}, column);

      delete columnDef.columns;

      if (column.columns) {
        var colSpan = getWidth(column);

        if (colSpan > 1) {
          columnDef.colSpan = colSpan;
        }

        addItems(column.columns, depth + 1);
      } else {
        var rowSpan = maxDepth - depth;

        if (rowSpan > 1) {
          columnDef.rowSpan = maxDepth - depth;
        }
      }

      result[depth].push(columnDef);
    });
  }

  addItems(columns, 0);
  return result;
}
function getColumns(columns) {
  var result = [];

  function setColumns(column) {
    if (column.columns == null) {
      result.push(column);
      return;
    }

    column.columns.forEach(function (child) {
      return setColumns(child);
    });
  }

  columns.forEach(function (column) {
    return setColumns(column);
  });
  return result;
}
function getDepth(columns) {
  if (columns == null) {
    return 0;
  }

  var depth = 0;
  columns.forEach(function (item) {
    depth = Math.max(depth, getDepth(item.columns));
  });
  return depth + 1;
}
function getWidth(column) {
  if (column.columns == null) {
    return 1;
  }

  var width = 0;
  column.columns.forEach(function (child) {
    width += getWidth(child);
  });
  return width;
}
function isNil(obj) {
  return obj == null;
}
function merge() {
  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
    objects[_key] = arguments[_key];
  }

  var firstObj = objects[0];
  var destination = isNil(firstObj) ? {} : firstObj;
  var existingObjects = objects.filter(function (source) {
    return !isNil(source);
  });
  var sources = [destination].concat(existingObjects);
  return all(sources);
}

function resolveProp(prop, args) {
  return prop instanceof Function ? prop(args) : prop;
}

var useStyles = /*#__PURE__*/makeStyles(function (theme) {
  return {
    container: {},
    tableWrapper: {},
    cellSelected: {
      backgroundColor: theme.palette.grey[100]
    },
    cellHovered: {
      backgroundColor: theme.palette.grey[200]
    }
  };
});

function MuiTable(props) {
  var data = props.data,
      columns = props.columns,
      containerProps = props.containerProps,
      tableWrapperProps = props.tableWrapperProps,
      headerProps = props.headerProps,
      bodyProps = props.bodyProps,
      rowProps = props.rowProps,
      headerRowProps = props.headerRowProps,
      bodyRowProps = props.bodyRowProps,
      defaultCellProps = props.cellProps,
      defaultHeaderCellProps = props.headerCellProps,
      defaultBodyCellProps = props.bodyCellProps,
      includeHeaders = props.includeHeaders,
      onHeaderClick = props.onHeaderClick,
      onCellClick = props.onCellClick,
      isCellHovered = props.isCellHovered,
      isCellSelected = props.isCellSelected,
      pagination = props.pagination,
      addPlaceholderRows = props.addPlaceholderRows,
      orderBy = props.orderBy,
      orderDirection = props.orderDirection,
      tableProps = _objectWithoutPropertiesLoose(props, ["data", "columns", "containerProps", "tableWrapperProps", "headerProps", "bodyProps", "rowProps", "headerRowProps", "bodyRowProps", "cellProps", "headerCellProps", "bodyCellProps", "includeHeaders", "onHeaderClick", "onCellClick", "isCellHovered", "isCellSelected", "pagination", "addPlaceholderRows", "orderBy", "orderDirection"]);

  var _useState = useState({
    hoveredColumn: null,
    hoveredRowData: null
  }),
      state = _useState[0],
      setState = _useState[1];

  var classes = useStyles();
  var hoveredColumn = state.hoveredColumn,
      hoveredRowData = state.hoveredRowData;
  return React.createElement("div", Object.assign({
    className: classes.container
  }, containerProps), React.createElement("div", Object.assign({
    className: classes.tableWrapper
  }, tableWrapperProps), React.createElement(Table, Object.assign({}, tableProps), includeHeaders && React.createElement(TableHead, Object.assign({}, headerProps), getHeaders(columns).map(function (headerRow, headerRowIndex) {
    return React.createElement(TableRow, Object.assign({}, resolveProp(rowProps, {
      column: null,
      rowData: null,
      hoveredColumn: hoveredColumn,
      hoveredRowData: hoveredRowData
    }), resolveProp(headerRowProps, {
      column: null,
      rowData: null,
      hoveredColumn: hoveredColumn,
      hoveredRowData: hoveredRowData
    }), {
      key: "header-row-" + headerRowIndex
    }), headerRow && headerRow.map(function (column, _columnIndex) {
      var _clsx;

      var contents = column.header || column.name;
      var isHovered = hoveredColumn && hoveredRowData && isCellHovered && isCellHovered({
        column: column,
        rowData: null,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      });
      var isSelected = isCellSelected && isCellSelected({
        column: column,
        rowData: null
      });
      var className = clsx((_clsx = {}, _clsx[classes.cellHovered] = isHovered, _clsx[classes.cellSelected] = isSelected, _clsx));
      var cellProps = merge({}, {
        className: className
      }, resolveProp(defaultCellProps, {
        column: column,
        rowData: null,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }), resolveProp(column.cellProps, {
        column: column,
        rowData: null,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }), resolveProp(defaultHeaderCellProps, {
        column: column,
        rowData: null,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }), resolveProp(column.headerCellProps, {
        column: column,
        rowData: null,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }));
      return React.createElement(TableCell, Object.assign({}, isCellHovered && {
        onMouseEnter: function onMouseEnter() {
          setState({
            hoveredColumn: column,
            hoveredRowData: null
          });
        },
        onMouseLeave: function onMouseLeave() {
          return setState({
            hoveredColumn: null,
            hoveredRowData: null
          });
        }
      }, {
        key: "header-cell-" + column.name,
        colSpan: column.colSpan,
        rowSpan: column.rowSpan
      }, cellProps), column.orderBy !== false && column.onHeaderClick !== false && (column.onHeaderClick || onHeaderClick) ? React.createElement(TableSortLabel, {
        active: orderBy === column.name || orderBy === column.orderBy,
        style: {
          width: 'inherit'
        },
        direction: orderDirection,
        onClick: function onClick() {
          return typeof column.onHeaderClick === 'function' ? column.onHeaderClick({
            column: column
          }) : onHeaderClick === null || onHeaderClick === void 0 ? void 0 : onHeaderClick({
            column: column
          });
        }
      }, contents) : contents);
    }));
  })), React.createElement(TableBody, Object.assign({}, bodyProps), data && data.map(function (rowData, rowIndex) {
    return React.createElement(TableRow, Object.assign({
      key: "body-row-" + rowIndex
    }, resolveProp(rowProps, {
      column: null,
      rowData: rowData,
      hoveredColumn: hoveredColumn,
      hoveredRowData: hoveredRowData
    }), resolveProp(bodyRowProps, {
      column: null,
      rowData: rowData,
      hoveredColumn: hoveredColumn,
      hoveredRowData: hoveredRowData
    })), getColumns(columns).map(function (column, _columnIndex) {
      var _clsx2;

      var contents = column.cell ? column.cell(rowData, rowIndex) : // @ts-ignore: add index signature
      rowData[column.name];
      var isHovered = hoveredColumn && hoveredRowData && isCellHovered && isCellHovered({
        column: column,
        rowData: rowData,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      });
      var isSelected = isCellSelected && isCellSelected({
        column: column,
        rowData: rowData
      });
      var className = clsx((_clsx2 = {}, _clsx2[classes.cellHovered] = isHovered, _clsx2[classes.cellSelected] = isSelected, _clsx2));
      var cellProps = merge({}, {
        className: className
      }, resolveProp(defaultCellProps, {
        column: column,
        rowData: rowData,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }), resolveProp(column.cellProps, {
        column: column,
        rowData: rowData,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }), resolveProp(defaultBodyCellProps, {
        column: column,
        rowData: rowData,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }), resolveProp(column.bodyCellProps, {
        column: column,
        rowData: rowData,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }));
      return React.createElement(TableCell, Object.assign({
        style: _extends({}, (onCellClick || column.onClick) && {
          cursor: 'pointer'
        })
      }, isCellHovered && {
        onMouseEnter: function onMouseEnter() {
          setState({
            hoveredColumn: column,
            hoveredRowData: rowData
          });
        },
        onMouseLeave: function onMouseLeave() {
          return setState({
            hoveredColumn: null,
            hoveredRowData: null
          });
        }
      }, onCellClick && {
        onClick: function onClick() {
          var _window$getSelection;

          if (((_window$getSelection = window.getSelection()) === null || _window$getSelection === void 0 ? void 0 : _window$getSelection.toString()) === '') {
            onCellClick({
              column: column,
              rowData: rowData
            }); // Can be overridden by cellProps.onClick on column definition
          }
        }
      }, {
        key: "body-cell-" + rowIndex + "-" + column.name
      }, cellProps), contents);
    }));
  }), pagination && addPlaceholderRows && pagination.rowsPerPage > (data ? data.length : 0) && Array.from({
    length: pagination.rowsPerPage - (data ? data.length : 0)
  }).map(function (rowData, rowIndex) {
    return React.createElement(TableRow, Object.assign({}, resolveProp(rowProps, {
      column: null,
      rowData: rowData,
      hoveredColumn: hoveredColumn,
      hoveredRowData: hoveredRowData
    }), resolveProp(bodyRowProps, {
      column: null,
      rowData: rowData,
      hoveredColumn: hoveredColumn,
      hoveredRowData: hoveredRowData
    }), {
      key: "body-row-placeholder-" + rowIndex
    }), columns.map(function (column) {
      var cellProps = merge({}, resolveProp(defaultCellProps, {
        column: column,
        rowData: rowData,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }), resolveProp(column.cellProps, {
        column: column,
        rowData: rowData,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }), resolveProp(defaultBodyCellProps, {
        column: column,
        rowData: rowData,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }), resolveProp(column.bodyCellProps, {
        column: column,
        rowData: rowData,
        hoveredColumn: hoveredColumn,
        hoveredRowData: hoveredRowData
      }));
      cellProps.style = _extends({}, cellProps.style, {
        visibility: 'hidden'
      });
      return React.createElement(TableCell, Object.assign({
        style: {
          visibility: 'hidden'
        },
        key: "body-cell-placeholder-" + rowIndex + "-" + column.name
      }, cellProps), "\xA0");
    }));
  })))), pagination && // @ts-ignore - `component` explicitly omitted from props but allowed (https://github.com/mui-org/material-ui/commit/8dc12394addced6c1ae34e0a05a3a799efe4ca6c#diff-33ba99dbf7e0ca4f0d9c07e27849f8d3R47)
  React.createElement(TablePagination, Object.assign({
    component: "div"
  }, pagination)));
}
// Workaround: Generic Props lost with React memo - https://github.com/DefinitelyTyped/DefinitelyTyped/issues/37087#issuecomment-542793243
// export default React.memo(MuiTable);

var typedMemo = React.memo;
var index = /*#__PURE__*/typedMemo(MuiTable);

export default index;
export { getColumns, getHeaders, useStyles };
//# sourceMappingURL=mui-table.esm.js.map
